# TODO: AgeInt should be optional. If not given, it can be calculated from Age.
# Therefore minimal columns are Age, Deaths, Exposures; example data should look
# this way

# TODO: in Age heaping diagnostics specify which ages are checked.
# give high medium low.

# TODO: check plotly scale translation (scale_y_log10)

# TODO: plot lines in middle of age group, i.e. 42.5, but show age interval (40-44)
# on hover tip. create age_label variable. This is only for abridged data.

# TODO: bar plots should properly cover age intervals

# TODO: give JC a text blob for "Ages to include in model fit",
# also annotate extrapolation jump off line

# TODO: in results plots make use of columns like Sex to include in plot titles

# TODO: PG wants nqx plot for probabilities
# TODO: label the quantile lines as such

# TODO: extrapfit ages should follow from OAG
# TODO: add reset button
# TODO: in data_out from lifetable, include grouping information.
#       For now look for "Sex","Time","Year","Period","Location","Group"
#       (either missing or same everywhere)
# Check why OAG can't be low: extrap age and OAnew can't conflict

#' @title `extension_check`
#' @description Check the provided files extension.
#' @param user_file character. File name with corresponding extension e.g. Should be one of ".csv",".xlsx",".xls",".tsv"
#' @return A character string with the corresponding file extension.
#' @importFrom stringr str_detect
#' @export
#' @examples
#' \dontrun{
#' extension_check(
#'     user_file = "data.csv")
#' }
#'

extension_check <- function(user_file) {
  # consider txt if it's delimited and reads correctly by read_delim()?
  # but we need to cathc failures intelligently in that case. A standard HMD
  # file would fail, for instance, but maybe it also should fail.
  allow_extensions <- c("csv", "xlsx", "xls", "tsv", "txt")
  ind                  <- str_detect(user_file, pattern = paste0(".", allow_extensions, "$"))
  allow_extensions[ind]
  
  }

#' @title `check_numeric`
#' @description Check if the following columns are numeric: (`Deaths`, `Exposures`, `Age`, and `AgeInt`).
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom purrr map
#' @importFrom rlang .data
#' @importFrom stringr str_flatten
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_numeric(
#'     data = data)

check_numeric <- function(data) {
  # data <- subset(data, select = c("Deaths", "Exposures", "Age", "AgeInt"))
  data <- subset(data, 
                 select = c("Deaths", 
                            "Exposures", 
                            "Age"))
  isnumeric <- data |>
    map( ~ is.numeric(.)) |>
    unlist()
  
  if (sum(isnumeric) < ncol(data)) {
    message <- paste0(
      "Please check the input data. Every column should be numeric, while columns ",
      str_flatten(names(data)[!isnumeric], collapse = ", "),
      " are not."
    )
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check numeric", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_missing_cols`
#' @description Check if any of the crucial columns are missing from the data: (`Deaths`, `Exposures`, `Age`).
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom stringr str_c str_flatten
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#'Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#'data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_missing_cols(
#'     data = data)
#'

# Should we even ask some of these? Like if there is no AgeInt the reader will not work.

check_missing_cols <- function(data) {
  # TR: DemoTools has the function age2int() to infer age intervals from an Age vector,
  # to technically we don't need it. We do however need ages specified as lower bounds of
  # abridged age groups (for the abridged lifetable function anyway). Let's not insist on
  # AgeInt being given.
  
  # TODO: Sex should not be insisted upon, but if it's there we should validate values
  # data <- subset(data, select = c("Deaths", "Exposures", "Age", "AgeInt", "Sex"))
  #
  # missing_cols <- setdiff(c("Deaths", "Exposures", "Age", "AgeInt", "Sex"), names(data))
  data <- subset(data, 
                 select = c("Deaths", 
                            "Exposures", 
                            "Age"))
  
  missing_cols <- setdiff(c("Deaths", 
                            "Exposures", 
                            "Age"), names(data))
  
  if (length(missing_cols) > 0) {
    message <- str_c(
      "The following columns are missing from the data:- ",
      str_flatten(missing_cols, collapse = ", "),
      ". The calculations are halted."
    )
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check missing columns", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_rows`
#' @description Check number of rows in the data. NOTE: only using the following columns: (`Deaths`, `Exposures`, `Age`, and `AgeInt`).
#' @param data tibble. A tibble generated by the output of the `read_data` function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#' Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#' data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)))
#'
#' check_rows(
#'     data = data)
#'     

check_rows <- function(data) {
  if (nrow(data) < 10) {
    message <- "The number of rows in the datast is less than expected. Please check the data before proceeding with calculations"
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check number of rows", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_nas`
#' @description Check if there missing data
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom stringr str_c str_flatten
#' @importFrom dplyr last
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#' Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#' data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_nas(
#'     data = data)
#'     

check_nas <- function(data) {
  nas <- data |>
    is.na() |>
    colSums()
  if (any(names(nas) == "AgeInt")) {
    if (nas["AgeInt"] == 1 & is.na(last(data$AgeInt))) {
      nas["AgeInt"] <- 0
    }
  }
  
  if (sum(nas) > 0) {
    message <- str_c(
      "Following columns have missing data:- ",
      str_flatten(names(nas)[nas > 0], collapse = ", "),
      ", n = ",
      str_flatten(nas[nas > 0], collapse = ", "),
      ". Please ensure there are no mistakes."
    )
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check = "check missing rows", message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_coherent`
#' @description Check for coherence within Age and between Age and AgeInt
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_coherent
#' @export
#' @examples
#' library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#' Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#' data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_coherent(
#'     data = data)
#'     

check_coherent <- function(data) {
  if ("AgeInt" %in% colnames(data)) {
    tst <- is_age_coherent(data$Age, data$AgeInt)
  } else {
    tst <- TRUE
  }
  if (!tst) {
    message <- "Age classes and age intervals are not coherent"
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check = "check age coherency", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_sequential`
#' @description Checks if Age is sorted sequentially
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_sequential
#' @export
#' @examples
#' library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#' Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#' data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_sequential(
#'     data = data)
#'     

check_sequential <- function(data) {
  tst <- is_age_sequential(data$Age)
  
  if (!tst) {
    message <- "The age is not sequential"
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check age sequential", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_redundant`
#' @description Check for redundant age specification
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom DemoTools is_age_redundant
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#' Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#' data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_redundant(
#'     data = data)
#'     

check_redundant <- function(data) {
  if ("AgeInt" %in% colnames(data)) {
    tst <- is_age_redundant(data$Age, data$AgeInt)
  } else {
    tst <- FALSE
  }
  if (tst) {
    message <- "Provided age data is redundant"
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check age redundancy", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_lower`
#' @description Check if ages start with 0.
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: message - `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#' Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#' data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#'
#' check_lower(
#'     data = data)
#'     

check_lower <- function(data) {
  if (min(data$Age) != 0) {
    message <- "Age should start with 0."
    
  } else {
    message <- NA_character_
    
  }
  
  res <- data.frame(check   = "check lower age", 
                    message = message)
  
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  
  return(res)
  
}

#' @title `check_sex`
#' @description Checks the data on sex provided by the user. We expect it ot be provided and contain information on either Males or Females or both. So that the column sex has either one, or two levels.
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with 3 columns: `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @export
#' @examples
#'  library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#' Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#' data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA),
#'                        sex = "Male")
#'
#' check_sex(
#'     data = data)
#'
#'

check_sex <- function(data) {
  if (any(str_detect("Sex", names(data)))) {
    lvls <- tolower(unique(data$Sex))

    if (all(lvls %in% c("male", "female", "total"))) {
      message <- NA_character_

    } else {
      message <- "If Sex variable is given, it should be coded with either `male`, `female`, or `total`."

    }

  } else {
    message <- NA_character_

  }

  res <- data.frame(check   = "check sex", message = message)

  res$pass <- ifelse(!is.na(message), "Fail", "Pass")

  return(res)
}

#' @title `check_data`
#' @description Upper level function that checks the data quality. Checks if the columns are numeric, if any of the columns is missing, if there is insufficient rows, if there are missing data entries, if ages do not start with 0, and also if ages are coherent, sequential and not redundant.
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @importFrom stringr str_c str_detect str_flatten
#' @importFrom DemoTools is_age_redundant is_age_sequential is_age_coherent
#' @importFrom purrr map
#' @export
#' @examples
#' library(tibble)
#' Exposures <- c(100958,466275,624134,559559,446736,370653,301862,249409,
#'               247473,223014,172260,149338,127242,105715,79614,53660,
#'               31021,16805,8000,4000,2000,1000)
#'
#' Deaths <- c(8674,1592,618,411,755,1098,1100,1357,
#'            1335,3257,2200,4023,2167,4578,2956,4212,
#'            2887,2351,1500,900,500,300)
#'
#' data <- tibble(Deaths = Deaths,
#'                        Exposures = Exposures,
#'                        Age = c(0, 1, seq(5, 100, by = 5)),
#'                        AgeInt = c(diff(Age), NA))
#' 
#' check_data(
#'     data = data)
#'     

check_data <- function(data) {
  
  # Ensure '.id' column exists
  if (!(".id" %in% colnames(data))) {
    data$.id <- "all"
  }
  
  # Extract unique .id values
  id <- unique(data$.id)
  
  # Perform checks
  
  # Split data by '.id', apply checks, and combine results
  split_data <- split(data, data$.id)
  
  ch1 <- do.call(rbind, lapply(split_data, check_numeric))
  ch2 <- do.call(rbind, lapply(split_data, check_missing_cols))
  ch3 <- do.call(rbind, lapply(split_data, check_rows))
  ch4 <- do.call(rbind, lapply(split_data, check_nas))
  ch5 <- do.call(rbind, lapply(split_data, check_coherent))
  ch6 <- do.call(rbind, lapply(split_data, check_sequential))
  ch7 <- do.call(rbind, lapply(split_data, check_redundant))
  ch8 <- do.call(rbind, lapply(split_data, check_lower))
  ch9 <- do.call(rbind, lapply(split_data, check_sex))
  
  # Combine all the check results

  result <- do.call(rbind, list(ch1, ch2, ch3,
                                ch4, ch5, ch6,
                                ch7, ch8, ch9))

  return(result)
}


#' @title `check_missing_cols_generic`
#' @description Check if Age column exists. For generic validation that doesn't require specific value columns.
#' @param data tibble. A tibble with at minimum an Age column.
#' @return A data.frame with validation results containing columns: `check`, `message`, `pass`.
#' @export
check_missing_cols_generic <- function(data) {
  missing_cols <- setdiff("Age", names(data))

  if (length(missing_cols) > 0) {
    message <- "The Age column is missing from the data. The calculations are halted."
  } else {
    message <- NA_character_
  }

  res <- data.frame(check = "check missing columns", message = message)
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  return(res)
}


#' @title `check_has_numeric`
#' @description Check if the data has at least one numeric column besides Age.
#' @param data tibble. A tibble with demographic data.
#' @return A data.frame with validation results containing columns: `check`, `message`, `pass`.
#' @export
check_has_numeric <- function(data) {
  # Get numeric columns excluding Age and internal columns
  exclude_cols <- c("Age", "AgeInt", ".id", ".id_label")
  numeric_cols <- names(data)[sapply(data, is.numeric)]
  value_cols <- setdiff(numeric_cols, exclude_cols)

  if (length(value_cols) == 0) {
    message <- "No numeric value columns found. Please include at least one numeric column besides Age."
  } else {
    message <- NA_character_
  }

  res <- data.frame(check = "check has numeric", message = message)
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  return(res)
}


#' @title `check_data_generic`
#' @description Generic data validation for modules that accept any numeric column (heaping, smoothing, graduation).
#' Requires only Age column and at least one numeric value column. Runs all standard age-related checks.
#' @param data tibble. A tibble with Age column and at least one numeric value column.
#' @return A data.frame with validation results containing columns: `check`, `message`, `pass`.
#' @export
#' @examples
#' library(tibble)
#' data <- tibble(
#'   Age = c(0, 1, seq(5, 100, by = 5)),
#'   births = runif(22, 1000, 10000),
#'   population = runif(22, 50000, 100000)
#' )
#' check_data_generic(data = data)
#'
check_data_generic <- function(data) {

  # Ensure '.id' column exists
  if (!(".id" %in% colnames(data))) {
    data$.id <- "all"
  }

  # Split data by '.id', apply checks, and combine results
  split_data <- split(data, data$.id)

  # Generic checks - only require Age and at least one numeric column
  ch1 <- do.call(rbind, lapply(split_data, check_missing_cols_generic))
  ch2 <- do.call(rbind, lapply(split_data, check_has_numeric))
  ch3 <- do.call(rbind, lapply(split_data, check_rows))
  ch4 <- do.call(rbind, lapply(split_data, check_nas))
  ch5 <- do.call(rbind, lapply(split_data, check_coherent))
  ch6 <- do.call(rbind, lapply(split_data, check_sequential))
  ch7 <- do.call(rbind, lapply(split_data, check_redundant))
  ch8 <- do.call(rbind, lapply(split_data, check_lower))

  # Combine all the check results
  result <- do.call(rbind, list(ch1, ch2, ch3, ch4, ch5, ch6, ch7, ch8))

  return(result)
}


#' @title `check_numeric_opag`
#' @description Check if the numeric columns for ODAP data (`Age`, `pop`) are numeric.
#' @param data tibble. A tibble containing population data for ODAP analysis.
#' @return A data.frame with 3 columns: `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom purrr map
#' @importFrom stringr str_flatten
#' @export
#' @examples
#' library(tibble)
#' data <- tibble(
#'   Age = 0:100,
#'   pop = c(9544406, 7471790, rep(1000000, 99)),
#'   name = "India",
#'   country_code = 356,
#'   sex = "M",
#'   year = 1971
#' )
#'
#' check_numeric_opag(data = data)
#'
check_numeric_opag <- function(data) {
  # For ODAP, we check Age and pop columns
  data_check <- subset(data, select = c("Age", "pop"))

  isnumeric <- data_check |>
    map(~ is.numeric(.)) |>
    unlist()

  if (sum(isnumeric) < ncol(data_check)) {
    message <- paste0(
      "Please check the input data. Every column should be numeric, while columns ",
      str_flatten(names(data_check)[!isnumeric], collapse = ", "),
      " are not."
    )
  } else {
    message <- NA_character_
  }

  data.frame(
    check = "check_numeric_opag",
    message = message,
    pass = ifelse(is.na(message), "Pass", "Fail")
  )
}


#' @title `check_missing_cols_opag`
#' @description Check if any of the crucial columns are missing from ODAP population data: (`Age`, `pop`).
#' @param data tibble. A tibble containing population data for ODAP analysis.
#' @return A data.frame with 3 columns: `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @importFrom stringr str_c str_flatten
#' @export
#' @examples
#' library(tibble)
#' data <- tibble(
#'   Age = 0:100,
#'   pop = c(9544406, 7471790, rep(1000000, 99)),
#'   name = "India",
#'   country_code = 356,
#'   sex = "M",
#'   year = 1971
#' )
#'
#' check_missing_cols_opag(data = data)
#'
check_missing_cols_opag <- function(data) {
  # For ODAP, we need Age and pop (population counts)
  # Optional columns: name, sex, year, country_code, nLx
  missing_cols <- setdiff(c("Age", "pop"), names(data))

  if (length(missing_cols) > 0) {
    message <- str_c(
      "The following columns are missing from the data: ",
      str_flatten(missing_cols, collapse = ", "),
      ". The ODAP calculations require Age and pop (population counts)."
    )
  } else {
    message <- NA_character_
  }

  data.frame(
    check = "check_missing_cols_opag",
    message = message,
    pass = ifelse(is.na(message), "Pass", "Fail")
  )
}


#' @title `check_nlx_if_present`
#' @description Check if nLx column is present and valid (numeric, no NAs).
#' @param data tibble. A tibble containing population data for ODAP analysis.
#' @return A data.frame with 3 columns: `check` - the name of the test, `message` - The error message with corresponding information generated if the test is failed (if the test is passed evaluates to NA), `pass` - binary result of the test either "Fail" or "Pass".
#' @export
#' @examples
#' library(tibble)
#' data <- tibble(
#'   Age = 0:100,
#'   pop = c(9544406, 7471790, rep(1000000, 99)),
#'   nLx = runif(101, 50000, 100000)
#' )
#'
#' check_nlx_if_present(data = data)
#'
check_nlx_if_present <- function(data) {
  # Check for both nLx and nlx (lowercase) since column names may be converted
  has_nlx <- "nLx" %in% names(data)
  has_nlx_lower <- "nlx" %in% names(data)

  if (has_nlx || has_nlx_lower) {
    # Use the correct column name
    col_name <- if (has_nlx) "nLx" else "nlx"

    # Check if numeric
    if (!is.numeric(data[[col_name]])) {
      return(data.frame(
        check = "check_nlx_numeric",
        message = "Column 'nLx' must be numeric.",
        pass = "Fail"
      ))
    }

    # Check for NAs
    if (any(is.na(data[[col_name]]))) {
      return(data.frame(
        check = "check_nlx_missing",
        message = "Column 'nLx' contains missing values.",
        pass = "Fail"
      ))
    }

    return(data.frame(
      check = "check_nlx",
      message = NA_character_,
      pass = "Pass"
    ))
  }

  # No nLx column - this is fine, will use WPP data
  return(data.frame(
    check = "check_nlx",
    message = NA_character_,
    pass = "Pass"
  ))
}


#' @title `check_sex_opag`
#' @description Checks sex variable for OPAG analysis. Unlike general check_sex,
#' this does NOT allow 'Total' since OPAG requires sex-specific mortality data
#' from WPP. Accepts various formats: M/F, m/f, Male/Female, male/female, males/females.
#' @param data tibble. A tibble generated by the output of the read_data function.
#' @return A data.frame with validation results containing columns: `check`, `message`, `pass`.
#' @export
#' @examples
#' library(tibble)
#' data <- tibble(Age = 0:100,
#'                pop = c(9544406, 7471790, rep(1000000, 99)),
#'                Sex = "m")
#' check_sex_opag(data = data)
#'
check_sex_opag <- function(data) {
  if (any(str_detect("Sex", names(data)))) {
    lvls <- unique(data$Sex)
    # Normalize sex values for comparison (handle m/f/male/female variants)
    lvls_lower <- tolower(lvls)
    valid_male <- lvls_lower %in% c("m", "male", "males")
    valid_female <- lvls_lower %in% c("f", "female", "females")

    if (all(valid_male | valid_female)) {
      message <- NA_character_
    } else {
      message <- "If Sex variable is given, it should be coded as `male` or `female` (or `Male`/`Female`, `m`/`f`). `Total` is not supported for OPAG."
    }
  } else {
    message <- NA_character_
  }

  res <- data.frame(check = "check sex", message = message)
  res$pass <- ifelse(!is.na(message), "Fail", "Pass")
  return(res)
}


#' @title `check_data_opag`
#' @description Upper level function that checks ODAP population data quality. Checks if the columns are numeric, if any of the columns is missing, if there is insufficient rows, if there are missing data entries, if ages do not start with 0, and also if ages are coherent, sequential and not redundant.
#' @param data tibble. A tibble containing population data for ODAP analysis with at minimum Age and pop columns.
#' @return A data.frame with validation results containing columns: `check`, `message`, `pass`.
#' @export
#' @examples
#' library(tibble)
#' data <- tibble(
#'   Age = 0:100,
#'   pop = c(9544406, 7471790, rep(1000000, 99)),
#'   name = "India",
#'   country_code = 356,
#'   sex = "M",
#'   year = 1971
#' )
#'
#' check_data_opag(data = data)
#'
check_data_opag <- function(data) {

  # Ensure '.id' column exists
  if (!(".id" %in% colnames(data))) {
    data$.id <- "all"
  }

  # Extract unique .id values
  id <- unique(data$.id)

  # Perform checks
  # Split data by '.id', apply checks, and combine results
  split_data <- split(data, data$.id)

  # ODAP-specific checks (using pop instead of Deaths/Exposures)
  ch1 <- do.call(rbind, lapply(split_data, check_numeric_opag))
  ch2 <- do.call(rbind, lapply(split_data, check_missing_cols_opag))
  ch3 <- do.call(rbind, lapply(split_data, check_rows))
  ch4 <- do.call(rbind, lapply(split_data, check_nas))
  ch5 <- do.call(rbind, lapply(split_data, check_coherent))
  ch6 <- do.call(rbind, lapply(split_data, check_sequential))
  ch7 <- do.call(rbind, lapply(split_data, check_redundant))
  ch8 <- do.call(rbind, lapply(split_data, check_lower))
  ch9 <- do.call(rbind, lapply(split_data, check_sex_opag))
  ch10 <- do.call(rbind, lapply(split_data, check_nlx_if_present))

  # Combine all the check results
  result <- do.call(rbind, list(ch1, ch2, ch3,
                                ch4, ch5, ch6,
                                ch7, ch8, ch9, ch10))

  return(result)
}
